// This file is auto-generated by @hey-api/openapi-ts

import { type Options, login, register, deleteUser, getUser, updateUser, removeAvatar, updateAvatar, removeCover, updateCover, validateSlug, deleteScheduling, getScheduling, createScheduling, updateScheduling, deleteEvent, getEvent, createEvent, updateEvent, getEventPublic, getAvails, createAvails, readRootGet } from '../sdk.gen';
import { queryOptions, type UseMutationOptions, type DefaultError } from '@tanstack/react-query';
import type { LoginData, LoginError, LoginResponse, RegisterData, RegisterError, RegisterResponse, DeleteUserData, DeleteUserResponse, GetUserData, UpdateUserData, UpdateUserError, UpdateUserResponse, RemoveAvatarData, RemoveAvatarResponse, UpdateAvatarData, UpdateAvatarError, UpdateAvatarResponse, RemoveCoverData, RemoveCoverResponse, UpdateCoverData, UpdateCoverError, UpdateCoverResponse, ValidateSlugData, DeleteSchedulingData, DeleteSchedulingError, GetSchedulingData, CreateSchedulingData, CreateSchedulingError, CreateSchedulingResponse, UpdateSchedulingData, UpdateSchedulingError, UpdateSchedulingResponse, DeleteEventData, DeleteEventError, DeleteEventResponse, GetEventData, CreateEventData, CreateEventError, CreateEventResponse, UpdateEventData, UpdateEventError, UpdateEventResponse, GetEventPublicData, GetAvailsData, CreateAvailsData, CreateAvailsError, CreateAvailsResponse, ReadRootGetData } from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? _heyApiClient).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const loginQueryKey = (options: Options<LoginData>) => createQueryKey('login', options);

/**
 * Login
 */
export const loginOptions = (options: Options<LoginData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await login({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: loginQueryKey(options)
    });
};

/**
 * Login
 */
export const loginMutation = (options?: Partial<Options<LoginData>>): UseMutationOptions<LoginResponse, LoginError, Options<LoginData>> => {
    const mutationOptions: UseMutationOptions<LoginResponse, LoginError, Options<LoginData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await login({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const registerQueryKey = (options: Options<RegisterData>) => createQueryKey('register', options);

/**
 * Register
 */
export const registerOptions = (options: Options<RegisterData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await register({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: registerQueryKey(options)
    });
};

/**
 * Register
 */
export const registerMutation = (options?: Partial<Options<RegisterData>>): UseMutationOptions<RegisterResponse, RegisterError, Options<RegisterData>> => {
    const mutationOptions: UseMutationOptions<RegisterResponse, RegisterError, Options<RegisterData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await register({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete User
 */
export const deleteUserMutation = (options?: Partial<Options<DeleteUserData>>): UseMutationOptions<DeleteUserResponse, DefaultError, Options<DeleteUserData>> => {
    const mutationOptions: UseMutationOptions<DeleteUserResponse, DefaultError, Options<DeleteUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserQueryKey = (options?: Options<GetUserData>) => createQueryKey('getUser', options);

/**
 * Get User
 */
export const getUserOptions = (options?: Options<GetUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserQueryKey(options)
    });
};

/**
 * Update User
 */
export const updateUserMutation = (options?: Partial<Options<UpdateUserData>>): UseMutationOptions<UpdateUserResponse, UpdateUserError, Options<UpdateUserData>> => {
    const mutationOptions: UseMutationOptions<UpdateUserResponse, UpdateUserError, Options<UpdateUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove Avatar
 */
export const removeAvatarMutation = (options?: Partial<Options<RemoveAvatarData>>): UseMutationOptions<RemoveAvatarResponse, DefaultError, Options<RemoveAvatarData>> => {
    const mutationOptions: UseMutationOptions<RemoveAvatarResponse, DefaultError, Options<RemoveAvatarData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeAvatar({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updateAvatarQueryKey = (options: Options<UpdateAvatarData>) => createQueryKey('updateAvatar', options);

/**
 * Update Avatar
 */
export const updateAvatarOptions = (options: Options<UpdateAvatarData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await updateAvatar({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: updateAvatarQueryKey(options)
    });
};

/**
 * Update Avatar
 */
export const updateAvatarMutation = (options?: Partial<Options<UpdateAvatarData>>): UseMutationOptions<UpdateAvatarResponse, UpdateAvatarError, Options<UpdateAvatarData>> => {
    const mutationOptions: UseMutationOptions<UpdateAvatarResponse, UpdateAvatarError, Options<UpdateAvatarData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateAvatar({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove Cover
 */
export const removeCoverMutation = (options?: Partial<Options<RemoveCoverData>>): UseMutationOptions<RemoveCoverResponse, DefaultError, Options<RemoveCoverData>> => {
    const mutationOptions: UseMutationOptions<RemoveCoverResponse, DefaultError, Options<RemoveCoverData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeCover({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updateCoverQueryKey = (options: Options<UpdateCoverData>) => createQueryKey('updateCover', options);

/**
 * Update Cover
 */
export const updateCoverOptions = (options: Options<UpdateCoverData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await updateCover({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: updateCoverQueryKey(options)
    });
};

/**
 * Update Cover
 */
export const updateCoverMutation = (options?: Partial<Options<UpdateCoverData>>): UseMutationOptions<UpdateCoverResponse, UpdateCoverError, Options<UpdateCoverData>> => {
    const mutationOptions: UseMutationOptions<UpdateCoverResponse, UpdateCoverError, Options<UpdateCoverData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateCover({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const validateSlugQueryKey = (options?: Options<ValidateSlugData>) => createQueryKey('validateSlug', options);

/**
 * Validate Slug
 */
export const validateSlugOptions = (options?: Options<ValidateSlugData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await validateSlug({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: validateSlugQueryKey(options)
    });
};

/**
 * Delete Scheduling
 */
export const deleteSchedulingMutation = (options?: Partial<Options<DeleteSchedulingData>>): UseMutationOptions<unknown, DeleteSchedulingError, Options<DeleteSchedulingData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteSchedulingError, Options<DeleteSchedulingData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteScheduling({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSchedulingQueryKey = (options?: Options<GetSchedulingData>) => createQueryKey('getScheduling', options);

/**
 * Get Scheduling
 */
export const getSchedulingOptions = (options?: Options<GetSchedulingData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getScheduling({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSchedulingQueryKey(options)
    });
};

export const createSchedulingQueryKey = (options: Options<CreateSchedulingData>) => createQueryKey('createScheduling', options);

/**
 * Create Scheduling
 */
export const createSchedulingOptions = (options: Options<CreateSchedulingData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createScheduling({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createSchedulingQueryKey(options)
    });
};

/**
 * Create Scheduling
 */
export const createSchedulingMutation = (options?: Partial<Options<CreateSchedulingData>>): UseMutationOptions<CreateSchedulingResponse, CreateSchedulingError, Options<CreateSchedulingData>> => {
    const mutationOptions: UseMutationOptions<CreateSchedulingResponse, CreateSchedulingError, Options<CreateSchedulingData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createScheduling({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Scheduling
 */
export const updateSchedulingMutation = (options?: Partial<Options<UpdateSchedulingData>>): UseMutationOptions<UpdateSchedulingResponse, UpdateSchedulingError, Options<UpdateSchedulingData>> => {
    const mutationOptions: UseMutationOptions<UpdateSchedulingResponse, UpdateSchedulingError, Options<UpdateSchedulingData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateScheduling({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Event
 */
export const deleteEventMutation = (options?: Partial<Options<DeleteEventData>>): UseMutationOptions<DeleteEventResponse, DeleteEventError, Options<DeleteEventData>> => {
    const mutationOptions: UseMutationOptions<DeleteEventResponse, DeleteEventError, Options<DeleteEventData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteEvent({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getEventQueryKey = (options?: Options<GetEventData>) => createQueryKey('getEvent', options);

/**
 * Get Event
 */
export const getEventOptions = (options?: Options<GetEventData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEvent({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getEventQueryKey(options)
    });
};

export const createEventQueryKey = (options: Options<CreateEventData>) => createQueryKey('createEvent', options);

/**
 * Create Event
 */
export const createEventOptions = (options: Options<CreateEventData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createEvent({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createEventQueryKey(options)
    });
};

/**
 * Create Event
 */
export const createEventMutation = (options?: Partial<Options<CreateEventData>>): UseMutationOptions<CreateEventResponse, CreateEventError, Options<CreateEventData>> => {
    const mutationOptions: UseMutationOptions<CreateEventResponse, CreateEventError, Options<CreateEventData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createEvent({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Event
 */
export const updateEventMutation = (options?: Partial<Options<UpdateEventData>>): UseMutationOptions<UpdateEventResponse, UpdateEventError, Options<UpdateEventData>> => {
    const mutationOptions: UseMutationOptions<UpdateEventResponse, UpdateEventError, Options<UpdateEventData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateEvent({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getEventPublicQueryKey = (options: Options<GetEventPublicData>) => createQueryKey('getEventPublic', options);

/**
 * Get Event Public
 */
export const getEventPublicOptions = (options: Options<GetEventPublicData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEventPublic({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getEventPublicQueryKey(options)
    });
};

export const getAvailsQueryKey = (options?: Options<GetAvailsData>) => createQueryKey('getAvails', options);

/**
 * Get Avails
 */
export const getAvailsOptions = (options?: Options<GetAvailsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAvails({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAvailsQueryKey(options)
    });
};

export const createAvailsQueryKey = (options: Options<CreateAvailsData>) => createQueryKey('createAvails', options);

/**
 * Create Avails
 */
export const createAvailsOptions = (options: Options<CreateAvailsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createAvails({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createAvailsQueryKey(options)
    });
};

/**
 * Create Avails
 */
export const createAvailsMutation = (options?: Partial<Options<CreateAvailsData>>): UseMutationOptions<CreateAvailsResponse, CreateAvailsError, Options<CreateAvailsData>> => {
    const mutationOptions: UseMutationOptions<CreateAvailsResponse, CreateAvailsError, Options<CreateAvailsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createAvails({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readRootGetQueryKey = (options?: Options<ReadRootGetData>) => createQueryKey('readRootGet', options);

/**
 * Read Root
 */
export const readRootGetOptions = (options?: Options<ReadRootGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readRootGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readRootGetQueryKey(options)
    });
};